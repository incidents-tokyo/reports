# ハッカー・プログラミング大全：読書メモ

###### tags: `メモ`

> 自分が大事だと思ったこと・知らなかったことを書いていく

[ToC]
## UNIX Buffer Overflow Exploit
### 仮想メモリ空間とプロセス
仮想メモリ空間は、次の4つの領域から構成される
(1) テキスト領域
実行ファイルの機械語命令
(2) データ領域
初期化されたデータ領域。グローバル変数。
(3) bss領域
初期化されていないデータ領域。ヒープ。
(4) スタック領域
ローカル変数。
### バウンドチェック漏れを利用したコードの実行
unsigned int retadr = 0x7ffff9f8;

memset(xxx, 'a', 12)
xxx[0] = 0xcc;
xxx[8] = retadr&0xff;
xxx[9] = (retadr>>8)&0xff;
xxx[10] = (retadr>>16)&0xff;
xxx[11] = (retadr>>24)&0xff;
xxx[12] = '\0';

retadrはローカルバッファのアドレスをprintf()して得る
### Shellコードの基礎
/bin/shを起動するCプログラム
const char \*argv[2]={"sh", (char \*)0};
const char \*envp[1]={(char \*)0};
execve("/bin/sh", argv, envp);

libcは内部でカーネルシステムコールを呼び出しており、各種ファイルI/Oやプロセス管理、UID/GID管理、タイマー管理といったサービスを提供している。
libc等はそのバージョンが異なればバイナリ互換性が保証されない。
そこで、libcを経由せずにカーネルシステムコールを直接呼び出したい。

カーネルシステムコールとシステムコール番号は、/usr/src/linux/include/asm-i386/unistd.hに記述されている。

p.36 インラインアセンブラにて記述されたコードのダンプ

### i386 FreeBSD Shellコード
Shellコードをコーディングする際には、まずexecファミリーのカーネルシステムコールの利用法を知る必要がある。
カーネルシステムコールの利用法が公開されているOSでは、その資料を入手すれば問題が解決する。
FreeBSDでは、/usr/include/sys/syscall.hにカーネルシステムコール一覧が定義されている。
p.44
### i386 Solaris Shellコード
ライブラリのstatic linkを指定してコンパイル
% gcc prog.c -static
生成された実行ファイルに含まれる関数について、それらを逆アセンブルして利用されているカーネルシステムコールをチェックする。
NULLにしたいがレジスタを引数にできない　－＞　コードの自己書き換え

## Win32 Buffer Overflow Exploit
### Win32 メモリアーキテクチャ
仮想アドレス空間は以下の空間に分けられる
(1) MS-DOSおよび16bit Windowsに対する互換性を確保するために必要な領域。（Win32アプリケーションはこの領域に対してアクセスできない）
(2) 各プロセスのプライベートアドレス空間。
(3) すべてのWin32プロセスが共有するデータ領域。（kernel32.dllやuser32.dll、gdi32.dll、advapi32.dllなどのシステムDLLが格納されている。）
(4) 仮想デバイスドライバや低水準メモリ管理コード、ファイルシステムコードなどが格納されている領域。（(3)と同様にすべてのWin32プロセスが共有している）

### ポインタ破壊によるAccess Violationとその回避
読み込み可能アドレス（書き込みを伴うならば書き込み可能アドレス）を指定することで回避できる。
読み込み可能領域は、プロセスに割り当てられたプライベート領域、およびWin32プロセス共有領域の一部である。
書き込み可能領域は、プロセスのプライベート領域内のデータ領域、bss領域、スタック領域のいずれか、およびWin32プロセス共有領域の一部である。

### eggコード
スタック上で動作する攻撃コードは一般的にeggと呼ばれる。
00H(NULLコード)、0DH、0AH(改行コード)を含まないようにする(アプリケーションによっては22Hなども)。

eggには以下のようなものが考えられる。
(1) ローカルシステム内の特定プログラムの実行
(2) ファイル、およびディスクの内容などを消去し、破壊
(3) システムの停止、再起動など
(4) ネットワーク経由でトロイの木馬やウイルスなどをインストールし実行

p.71 msvcrt.dll.dll中に含まれる関数のアドレスの取得方法

LoadLibrary("msvcrt.dll");を行い、そのライブラリハンドルを取得することでdllのバージョンに依存しないeggが作れる。

### ジャストインタイムデバッギング
プロセスの異常終了時にプロセスのデバッグを行える。
レジスタに指定しとく。
### スレッドコンテキストの取得
プロセスID、およびイベントオブジェクトハンドルより取得する。
### 動作中のプロセスとプロセスの所有するヒープの列挙
#### プロセスの列挙
列挙のためにプロセスのスナップショットを取得する必要があり、CreateToolhelp32Snapshot() APIを用いる。
これで得られるスナップショットハンドルを用いてプロセスの列挙を行う。
Process32Next()が失敗するまで、Process32First()をループする。
#### ヒープリスト（ヒープID）の列挙
スナップショットハンドルを用いてヒープリストの列挙を行う
Heap32ListNext()が失敗するまで、Heap32ListFirst()をループする。
#### ヒープエントリ（各ブロックのアドレスとサイズ）の列挙
プロセスIDとヒープIDを用いる。
Heap32Next()が失敗するまで、Heap32First()をループする。

### プロセスのメモリの読み出しと書き込み
OpenProcess() APIで指定したプロセスのプロセスオブジェクトのハンドルを取得する。
その後、ReadProcessMemory() APIを用いて指定プロセスのメモリを読み出すことができる。
書き込みはWriteProcessMemory() APIを用いる。

## Unix バックドア
### ローカルバックドアの種類
(1) 新規インストール型
パーミッション4755で、UIDを0にして/bin/shを起動する典型的なrootshellプログラム
(2) 設定変更型
vi等のエディタのパーミッションを4755に変更することにより機能するrootshellプログラム
(3) プログラム改ざん型
suコマンドといったsuidプログラムに特別な入力があった場合にrootshellとして起動するプログラム

(1)と(2)は改ざん検知ツールで発見・対処できるので、今回はプログラム改ざん型について考える。
### コマンド置換型バックドア
ソースコードが公開されていないシステムを対象にする。
バックドア、およびトロイの木馬について解説する。
(1) rootshell
root権限を得ることのできるバックドア専用のコマンド。
あくまでOS(カーネル)の機能を利用していて、explitと区別している。
(2) su trojan
ローカルユーザとなったクラッカーがexplit等を利用せずrootになるための手段。
管理者をだましてパスワードを入力させ、ロギングする。
(3) ls trojan
カレントディレクトリを最優先にPATHを通す管理者に対して、ホームディレクトリにrootshellを作成するlsトロイを設置しておく。
(4) プロセスの隠蔽
root権限を得たクラッカーは、snifferや後述するリモートバックドアといったプロセスを走らせることが多い。
psコマンドを改ざんし、指定した特定のプロセスの列挙を防ぐ。

### rootshell
p.128 シンプルなrootshell.c
p.128 suidプログラムの列挙
既存のSUIDプログラムを改ざん。引数に特別な文字列を指定した場合にのみrootshellとして機能する。
p.130 (4)オリジナルプログラムのsuidビットを落とす。
#### ファイルステータス情報の改ざん
日付はtouchコマンド
ファイルサイズはごみの追加か、自己展開可能な圧縮

### su torojan
suトロイは性質上一回目(ロギング時)は必ず失敗し、二回目以降(指定ユーザーのパスワードをロギング後)は通常のsuコマンドとして動作する。
対策：ホストの管理権限を持つユーザは、suコマンド等、何らかのパスワードの入力を要求するコマンドは絶対パスで指定、実行する。

### ソースコード改ざん型バックドア
改ざんした後のat\.cを/usr/src/usr\.bin/atでmake、make installする。

### リモートバックドアの種類
(1) ネットワークサービス利用型バックドア
バックドアサービスのエントリをinetd.confに追加したり、バックドア専用アカウントをパスワードファイルに追加してssh接続するなど。
(2) 既存ネットワークサービスプログラム・ソースコード改ざん型バックドア
ソースコードの公開されているシステム既存のサービスプログラムのソースコードを改ざんすることによって、バックドアを実装、システムにインストールするタイプのもの。
(3) ネットワークサービスプログラムバックドア
特別な専用サービスプログラムでバックドアを実現するタイプのもの。

#### 設定ファイル改ざん型バックドア
- パスワードファイルの改ざん
- rサービスバックドア
リモートシステム
- inetdサービスバックドア
inetdは、/etc/rcでboot時に起動され、指定されたインターネットソケットを監視し接続を待つ。監視対象となっているソケットに対して接続要求が出されるとそのソケットに対応したサービスプログラムを起動する。
- NFSバックドア
シェアした後、上記のような設定ファイルを改ざんする。

p.154 inetdについて

#### ネットワークサービスプログラムバックドアの種類
- TCP shell
- UDP shell
p.172
- ICMP shell
p.180

### ライブラリバックドア
ライブラリとは、再利用を目的として作成されたコンパイル済みの関数の集合である。
$ ldd /usr/bin/su

ライブラリソースコード /usr/src/lib
#### libcバックドアの種類
- パスワードのロギング
getpass()関数の改ざん。どのライブラリで提供されているか、$ man getpass
$ cd /usr/src/lib/libc
$ grep -r getpass *
$ make
$ make install
- rootshell
(1) libc/getpass()の改ざん
(2) libcrypt/crypt()の改ざん
(3) libc/getopt()の改ざん
- TCPパケットのロギング
libcのsend()/recv()関数の改ざん

### カーネルバックドア
- ファイルの隠蔽
例えば、各種ログファイル。
- ファイルステータス情報の改ざん
- rootshell
システムコールにバックドアを仕込む。
- カーネル改ざん検査のバイパス
ファイル改ざん検査の際に、openするカーネルファイルをカーネル内でリダイレクトし、チェックサム検査等のファイル改ざん検査をバイパスする。


## Win32 リモートバックドア
キーストロークロギング
p.265
スクリーンダンプ
p.270
### TCP shellバックドア
p.274

---
